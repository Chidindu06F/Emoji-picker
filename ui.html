<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Emoji Picker</title>
    <style>
      :root {
        --bg: #0f0f10;
        --surface: #18181a;
        --surface-2: #1f1f22;
        --text: #ffffff;
        --muted: #bdbdbd;
        --border: #2a2a2e;
        --border-strong: #3a3a3f;
        --accent: #2b2b31;
        --shadow: 0 1px 2px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: var(--bg);
        color: var(--text);
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI,
          Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji,
          Noto Color Emoji, sans-serif;
      }
      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      .search-wrapper {
        padding: 14px 14px 10px 14px;
        background: var(--bg);
        position: sticky;
        top: 0;
        z-index: 1;
        border-bottom: 1px solid var(--border);
      }
      .search-input {
        width: 100%;
        height: 44px;
        padding: 10px 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--bg);
        color: var(--text);
        outline: none;
        box-shadow: var(--shadow);
      }
      .search-input::placeholder {
        color: var(--muted);
      }
      .search-input:focus {
        border-color: var(--border-strong);
      }
      .emoji-grid {
        display: grid;
        /* 5 fixed columns, rows grow as needed */
        grid-template-columns: repeat(5, 60px);
        grid-auto-rows: 60px;
        grid-auto-flow: row;
        gap: 12px;
        padding: 14px;
      }
      .emoji-grid::-webkit-scrollbar {
        display: none;
        width: 0;
        height: 0;
      }
      .scroll-area {
        position: relative;
        overflow-x: hidden;
        overflow-y: auto;
        -ms-overflow-style: none;
        scrollbar-width: none;
        margin-bottom: 48px; /* Space for sticky footer */
      }
      .scroll-area::-webkit-scrollbar {
        display: none;
        width: 0;
        height: 0;
      }
      .recents-wrap {
        position: sticky;
        top: 0;
        z-index: 2;
        backdrop-filter: blur(8px);
        background: rgba(24, 24, 26, 0.6);
        border-bottom: 1px solid var(--border);
      }
      .recent-title {
        color: var(--muted);
        font-size: 12px;
        padding: 6px 14px 0 14px;
      }
      .recents {
        padding: 4px 14px;
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: 36px;
        gap: 8px;
        min-height: 36px;
      }
      .emoji-recent {
        height: 36px;
        width: 36px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: var(--surface);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 22px;
      }
      .emoji-recent:hover {
        border-color: var(--border-strong);
        background: var(--accent);
      }
      .scroll-btn {
        position: fixed;
        right: 14px;
        height: 36px;
        width: 36px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface-2);
        color: var(--text);
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow);
      }
      .scroll-btn:hover {
        background: var(--accent);
        border-color: var(--border-strong);
      }
      .scroll-btn.down {
        bottom: 54px; /* 40px above footer (footer height + margin) */
      }
      .scroll-btn.up {
        bottom: 96px; /* 42px above down button */
      }
      .emoji-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 60px;
        width: 60px;
        border-radius: 16px;
        border: 1px solid var(--border);
        background: var(--surface);
        cursor: pointer;
        transition: transform 140ms ease, border-color 140ms ease,
          background 140ms ease, box-shadow 140ms ease;
        font-size: 36px;
        line-height: 1;
        user-select: none;
        will-change: transform;
        font-family: "Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji",
          "Twemoji Mozilla", "EmojiOne Color", "Segoe UI Symbol", Inter,
          ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial, sans-serif;
      }
      .emoji-btn:hover {
        transform: scale(1.06);
        border-color: var(--border-strong);
        background: var(--accent);
        box-shadow: var(--shadow);
      }
      .emoji-btn:active {
        transform: scale(0.98);
      }
      .emoji-btn:focus-visible {
        outline: none;
        border-color: var(--border-strong);
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.06) inset, var(--shadow);
      }
      .footer {
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100vw;
        background-color: #0f0f10;
        color: var(--muted);
        text-align: center;
        font-size: 12px;
        padding: 10px 0 8px 0;
        z-index: 100;
        box-shadow: 0 -1px 6px rgba(0, 0, 0, 0.12);
        letter-spacing: 0.01em;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="search-wrapper">
        <input
          id="search"
          class="search-input"
          type="text"
          placeholder="Search emojis..."
          autocomplete="off"
        />
      </div>
      <div
        class="tip"
        style="
          padding: 8px 14px 0 14px;
          color: var(--muted);
          font-size: 13px;
          margin-bottom: 12px;
        "
      >
        Tip: To resize an emoji, select it and adjust the font size
      </div>
      <div class="scroll-area" id="scrollArea">
        <div class="recents-wrap">
          <div class="recent-title" id="recentTitle">Recently used</div>
          <div id="recents" class="recents"></div>
        </div>
        <div id="grid" class="emoji-grid" aria-live="polite"></div>
      </div>
      <button id="btnDown" class="scroll-btn down" title="Scroll to bottom">
        â†“
      </button>
      <button id="btnUp" class="scroll-btn up" title="Scroll to top">â†‘</button>
    </div>
    <footer class="footer">Designed and built by DinduðŸ’—</footer>

    <script>
      // Utility: debounce
      function debounce(fn, delay) {
        let t = null;
        return function (...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), delay);
        };
      }

      // Partial CLDR short names map for emojis in U+1F600..U+1FAFF
      const CLDR_SHORT_NAMES = {
        "ðŸ˜€": "grinning face",
        "ðŸ˜ƒ": "grinning face with big eyes",
        "ðŸ˜„": "grinning face with smiling eyes",
        "ðŸ˜": "beaming face with smiling eyes",
        "ðŸ˜†": "grinning squinting face",
        "ðŸ˜…": "grinning face with sweat",
        "ðŸ¤£": "rolling on the floor laughing",
        "ðŸ˜‚": "face with tears of joy",
        "ðŸ™‚": "slightly smiling face",
        "ðŸ™ƒ": "upside-down face",
        "ðŸ˜‰": "winking face",
        "ðŸ˜Š": "smiling face with smiling eyes",
        "ðŸ˜‡": "smiling face with halo",
        "ðŸ¥¹": "face holding back tears",
        "ðŸ˜": "smiling face with heart-eyes",
        "ðŸ¥°": "smiling face with hearts",
        "ðŸ˜˜": "face blowing a kiss",
        "ðŸ˜—": "kissing face",
        "â˜ºï¸": "smiling face",
        "ðŸ˜š": "kissing face with closed eyes",
        "ðŸ˜™": "kissing face with smiling eyes",
        "ðŸ˜‹": "face savoring food",
        "ðŸ˜›": "face with tongue",
        "ðŸ˜œ": "winking face with tongue",
        "ðŸ¤ª": "zany face",
        "ðŸ˜": "squinting face with tongue",
        "ðŸ¤‘": "money-mouth face",
        "ðŸ¤—": "hugging face",
        "ðŸ¤­": "face with hand over mouth",
        "ðŸ«¢": "face with open eyes and hand over mouth",
        "ðŸ«£": "face with peeking eye",
        "ðŸ¤«": "shushing face",
        "ðŸ¤”": "thinking face",
        "ðŸ« ": "melting face",
        "ðŸ¤": "zipper-mouth face",
        "ðŸ¤¨": "face with raised eyebrow",
        "ðŸ˜": "neutral face",
        "ðŸ˜‘": "expressionless face",
        "ðŸ˜¶": "face without mouth",
        "ðŸ«¥": "dotted line face",
        "ðŸ˜¶â€ðŸŒ«ï¸": "face in clouds",
        "ðŸ˜": "smirking face",
        "ðŸ˜’": "unamused face",
        "ðŸ™„": "face with rolling eyes",
        "ðŸ˜¬": "grimacing face",
        "ðŸ˜®â€ðŸ’¨": "face exhaling",
        "ðŸ¤¥": "lying face",
        "ðŸ˜Œ": "relieved face",
        "ðŸ˜”": "pensive face",
        "ðŸ˜ª": "sleepy face",
        "ðŸ¤¤": "drooling face",
        "ðŸ˜´": "sleeping face",
        "ðŸ˜·": "face with medical mask",
        "ðŸ¤’": "face with thermometer",
        "ðŸ¤•": "face with head-bandage",
        "ðŸ¤¢": "nauseated face",
        "ðŸ¤®": "face vomiting",
        "ðŸ¤§": "sneezing face",
        "ðŸ˜µ": "dizzy face",
        "ðŸ˜µâ€ðŸ’«": "face with spiral eyes",
        "ðŸ¥´": "woozy face",
        "ðŸ˜Ž": "smiling face with sunglasses",
        "ðŸ¤“": "nerd face",
        "ðŸ§": "face with monocle",
        "ðŸ˜•": "confused face",
        "ðŸ«¤": "face with diagonal mouth",
        "ðŸ˜Ÿ": "worried face",
        "ðŸ™": "slightly frowning face",
        "â˜¹ï¸": "frowning face",
        "ðŸ˜®": "face with open mouth",
        "ðŸ˜¯": "hushed face",
        "ðŸ˜²": "astonished face",
        "ðŸ˜³": "flushed face",
        "ðŸ¥µ": "hot face",
        "ðŸ¥¶": "cold face",
        "ðŸ˜±": "face screaming in fear",
        "ðŸ˜¨": "fearful face",
        "ðŸ˜°": "anxious face with sweat",
        "ðŸ˜¥": "sad but relieved face",
        "ðŸ˜“": "downcast face with sweat",
        "ðŸ¤¯": "exploding head",
        "ðŸ˜¤": "face with steam from nose",
        "ðŸ˜­": "loudly crying face",
        "ðŸ˜¢": "crying face",
        "ðŸ˜©": "weary face",
        "ðŸ˜«": "tired face",
        "ðŸ˜–": "confounded face",
        "ðŸ˜£": "persevering face",
        "ðŸ˜ ": "angry face",
        "ðŸ˜¡": "enraged face",
        "ðŸ¤¬": "face with symbols on mouth",
        "ðŸ˜º": "grinning cat",
        "ðŸ˜¸": "grinning cat with smiling eyes",
        "ðŸ˜¹": "cat with tears of joy",
        "ðŸ˜»": "smiling cat with heart-eyes",
        "ðŸ˜¼": "cat with wry smile",
        "ðŸ˜½": "kissing cat",
        "ðŸ™€": "weary cat",
        "ðŸ˜¿": "crying cat",
        "ðŸ˜¾": "pouting cat",
      };

      // Build a large emoji set programmatically using Unicode ranges, filtered by the Emoji property
      // This yields well over 1,000 emojis on most systems without external files
      function generateEmojiSet() {
        // Simplified sequential set from U+1F600..U+1FAFF (inclusive)
        const start = 0x1f600;
        const end = 0x1faff;
        const isEmojiSeq = (ch) => /\p{Extended_Pictographic}/u.test(ch);
        const seq = [];
        for (let cp = start; cp <= end; cp++) {
          const ch = String.fromCodePoint(cp);
          if (isEmojiSeq(ch)) {
            seq.push({
              emoji: ch,
              name: CLDR_SHORT_NAMES[ch] || undefined,
              cp,
              keywords: [ch, "U+" + cp.toString(16).toUpperCase()],
            });
          }
        }
        return seq;
        // Legacy below (unreachable)
        const ranges = [
          [0x1f300, 0x1f5ff], // Misc Symbols & Pictographs
          [0x1f600, 0x1f64f], // Emoticons
          [0x1f680, 0x1f6ff], // Transport & Map
          [0x1f700, 0x1f77f], // Alchemical
          [0x1f780, 0x1f7ff], // Geometric Extended
          [0x1f800, 0x1f8ff], // Supplemental Arrows-C
          [0x1f900, 0x1f9ff], // Supplemental Symbols and Pictographs
          [0x1fa00, 0x1faff], // Symbols and Pictographs Extended-A
          [0x2600, 0x26ff], // Misc symbols
          [0x2700, 0x27bf], // Dingbats
        ];
        const isEmoji = (ch) => /\p{Extended_Pictographic}/u.test(ch);
        const list = [];
        for (const [start, end] of ranges) {
          for (let cp = start; cp <= end; cp++) {
            const ch = String.fromCodePoint(cp);
            if (isEmoji(ch)) {
              list.push({
                emoji: ch,
                name: undefined,
                cp,
                keywords: [ch, "U+" + cp.toString(16).toUpperCase()],
              });
            }
          }
        }
        // Add commonly used sequences that are outside single code points
        const extraCommon = [
          "â¤\uFE0F",
          "âœ¨",
          "ðŸ”¥",
          "âš¡\uFE0F",
          "â­\uFE0F",
          "â­•\uFE0F",
          "âœ…",
          "âŒ",
          "â—\uFE0F",
          "â“\uFE0F",
          "â˜€\uFE0F",
          "ðŸŒ™",
          "ðŸŒŸ",
          "ðŸŽ‰",
          "ðŸŽŠ",
          "ðŸ‘",
          "ðŸ‘Ž",
          "ðŸ™",
          "ðŸ‘",
          "ðŸ’ª",
          "ðŸ’¯",
          "ðŸ¥‡",
          "ðŸ¥ˆ",
          "ðŸ¥‰",
          "ðŸš€",
          "ðŸ§ ",
          "ðŸ› \uFE0F",
          "ðŸ§°",
          "ðŸ§ª",
          "ðŸ§©",
          "ðŸ“Œ",
          "ðŸ“",
          "ðŸ”",
          "ðŸ”Ž",
          "ðŸ–¤",
          "ðŸ’œ",
          "ðŸ’™",
          "ðŸ’š",
          "ðŸ’›",
          "ðŸ§¡",
          "ðŸ©·",
          "ðŸ’—",
          "ðŸ’–",
          "ðŸ’˜",
          "ðŸ’",
          "ðŸ’Ÿ",
          "ðŸ’”",
        ];
        const extraCommonObjs = extraCommon.map((e) => ({
          emoji: e,
          name: undefined,
          keywords: [
            e,
            "heart",
            "star",
            "sparkle",
            "fire",
            "rocket",
            "check",
            "cross",
            "alert",
            "question",
            "love",
          ],
        }));

        // Explicitly include face smiling and face affection emojis
        const extraFaces = [
          // Face Smiling
          { e: "ðŸ˜€", k: ["face smiling", "smile", "grinning"] },
          { e: "ðŸ˜ƒ", k: ["face smiling", "smile", "grinning", "big eyes"] },
          { e: "ðŸ˜„", k: ["face smiling", "smile", "smiling eyes"] },
          { e: "ðŸ˜", k: ["face smiling", "beaming", "smile"] },
          { e: "ðŸ˜†", k: ["face smiling", "laugh", "grinning squinting"] },
          { e: "ðŸ˜…", k: ["face smiling", "smile", "sweat"] },
          { e: "ðŸ˜‚", k: ["face smiling", "joy", "tears of joy", "laugh"] },
          {
            e: "ðŸ¤£",
            k: ["face smiling", "rofl", "rolling on the floor laughing"],
          },
          { e: "â˜º\uFE0F", k: ["face smiling", "smiling face"] },
          { e: "ðŸ™‚", k: ["face smiling", "slightly smiling"] },
          { e: "ðŸ˜Š", k: ["face smiling", "smiling face with smiling eyes"] },
          // Face Affection
          {
            e: "ðŸ¥°",
            k: ["face affection", "smiling face with hearts", "love"],
          },
          { e: "ðŸ˜", k: ["face affection", "heart eyes", "love"] },
          { e: "ðŸ˜˜", k: ["face affection", "face blowing a kiss", "kiss"] },
          { e: "ðŸ˜—", k: ["face affection", "kissing face", "kiss"] },
          {
            e: "ðŸ˜™",
            k: ["face affection", "kissing face with smiling eyes", "kiss"],
          },
          {
            e: "ðŸ˜š",
            k: ["face affection", "kissing face with closed eyes", "kiss"],
          },
        ];
        const extraFaceObjs = extraFaces.map((f) => ({
          emoji: f.e,
          name: f.k[0],
          keywords: [f.e, ...f.k],
        }));

        // Curated sets: core faces, unhappy/sad faces, monkeys, cats, babies
        const faceCore = [
          ["ðŸ˜‰", "winking face", ["wink", "face", "winking"]],
          ["ðŸ˜‹", "face savoring food", ["yum", "savoring", "delicious"]],
          ["ðŸ˜œ", "winking face with tongue", ["tongue", "wink", "playful"]],
          ["ðŸ˜", "squinting face with tongue", ["tongue", "squint", "playful"]],
          ["ðŸ˜›", "face with tongue", ["tongue", "face"]],
          ["ðŸ¤ª", "zany face", ["crazy", "zany", "goofy"]],
          ["ðŸ¤¨", "face with raised eyebrow", ["raised eyebrow", "skeptical"]],
          ["ðŸ§", "face with monocle", ["monocle", "inspect", "fancy"]],
          ["ðŸ¤“", "nerd face", ["nerd", "glasses"]],
          ["ðŸ˜Ž", "smiling face with sunglasses", ["cool", "sunglasses"]],
          ["ðŸ¥¸", "disguised face", ["disguise", "glasses", "mustache"]],
          ["ðŸ¤©", "star-struck", ["star", "amazed"]],
          ["ðŸ¤ ", "cowboy hat face", ["cowboy", "hat"]],
          ["ðŸ˜", "smirking face", ["smirk", "sarcasm"]],
          ["ðŸ™ƒ", "upside-down face", ["upside down"]],
          ["ðŸ¥²", "smiling face with tear", ["tear", "bittersweet"]],
          ["ðŸ˜‡", "smiling face with halo", ["halo", "angel"]],
          ["ðŸ˜Œ", "relieved face", ["relieved", "calm"]],
          ["ðŸ« ", "melting face", ["melting"]],
          ["ðŸ¤¤", "drooling face", ["drool", "hungry"]],
          ["ðŸ˜ª", "sleepy face", ["sleepy", "snooze"]],
          ["ðŸ˜´", "sleeping face", ["sleep", "zzz"]],
          ["ðŸ˜·", "face with medical mask", ["mask", "sick"]],
          ["ðŸ¤¯", "exploding head", ["mind blown", "explosion"]],
          ["ðŸ¤", "zipper-mouth face", ["zipper", "secret"]],
          ["ðŸ¤¥", "lying face", ["pinocchio", "lying"]],
          ["ðŸ¤«", "shushing face", ["quiet", "shh"]],
          ["ðŸ¤­", "face with hand over mouth", ["oops", "gasp"]],
          ["ðŸ«¡", "saluting face", ["salute"]],
          [
            "ðŸ«¢",
            "face with open eyes and hand over mouth",
            ["surprised", "gasp"],
          ],
          ["ðŸ«£", "face with peeking eye", ["peek", "shy"]],
          ["ðŸ¤—", "hugging face", ["hug", "open hands"]],
          ["ðŸ¤”", "thinking face", ["think", "hmm"]],
          ["ðŸ˜¶", "face without mouth", ["mute", "no mouth"]],
          ["ðŸ«¥", "dotted line face", ["invisible", "dotted"]],
          ["ðŸ˜®", "face with open mouth", ["surprised", "open mouth"]],
          ["ðŸ˜¯", "hushed face", ["hushed", "surprised"]],
          ["ðŸ˜²", "astonished face", ["astonished", "amazed"]],
          ["ðŸ¥±", "yawning face", ["yawn", "tired"]],
          ["ðŸ™„", "face with rolling eyes", ["eyeroll", "annoyed"]],
          [
            "ðŸ¥¹",
            "face holding back tears",
            ["tears", "holding back", "emotional"],
          ],
          ["ðŸ¥º", "pleading face", ["please", "puppy eyes"]],
        ];
        const faceUnhappy = [
          ["ðŸ™", "slightly frowning face", ["unhappy", "frown", "slightly"]],
          ["â˜¹\uFE0F", "frowning face", ["unhappy", "frown"]],
          ["ðŸ˜ž", "disappointed face", ["sad", "disappointed"]],
          ["ðŸ˜Ÿ", "worried face", ["worried", "concerned"]],
          ["ðŸ˜ ", "angry face", ["angry", "mad"]],
          ["ðŸ˜¡", "enraged face", ["pouting", "angry", "mad"]],
          [
            "ðŸ¤¬",
            "face with symbols on mouth",
            ["swearing", "cussing", "angry"],
          ],
          ["ðŸ˜£", "persevering face", ["persevere", "struggle"]],
          ["ðŸ˜–", "confounded face", ["confounded", "frustrated"]],
          ["ðŸ˜«", "tired face", ["tired", "exhausted"]],
          ["ðŸ˜©", "weary face", ["weary", "exhausted"]],
          ["ðŸ˜¢", "crying face", ["sad", "crying"]],
          ["ðŸ˜­", "loudly crying face", ["crying", "sobbing"]],
          ["ðŸ˜¤", "face with steam from nose", ["triumph", "annoyed"]],
          ["ðŸ˜®\u200D\uD83D\uDCA8", "face exhaling", ["exhale", "sigh"]],
          ["ðŸ˜°", "anxious face with sweat", ["anxious", "sweat"]],
          ["ðŸ˜¥", "sad but relieved face", ["relieved", "sad"]],
          ["ðŸ˜“", "downcast face with sweat", ["sweat", "downcast"]],
          ["ðŸ˜¨", "fearful face", ["fearful", "scared"]],
          ["ðŸ˜±", "face screaming in fear", ["scream", "fear"]],
          ["ðŸ˜³", "flushed face", ["flushed", "embarrassed"]],
          ["ðŸ¥µ", "hot face", ["hot", "overheated"]],
          ["ðŸ¥¶", "cold face", ["cold", "freezing"]],
          ["ðŸ˜¶\u200D\uD83C\uDF2B\uFE0F", "face in clouds", ["foggy", "clouds"]],
          ["ðŸ˜µ", "dizzy face", ["dizzy", "x eyes"]],
          [
            "ðŸ˜µ\u200D\uD83D\uDD2F",
            "face with spiral eyes",
            ["spiral eyes", "dizzy"],
          ],
          ["ðŸ¤’", "face with thermometer", ["thermometer", "sick"]],
          ["ðŸ¤•", "face with head-bandage", ["bandage", "injury"]],
          ["ðŸ¤¢", "nauseated face", ["nausea", "sick"]],
          ["ðŸ¤®", "face vomiting", ["vomit", "sick"]],
          ["ðŸ¤§", "sneezing face", ["sneeze", "sick"]],
          ["ðŸ¥´", "woozy face", ["woozy", "tipsy"]],
          ["ðŸ˜”", "pensive face", ["pensive", "sad"]],
          ["ðŸ˜•", "confused face", ["confused", "unsure"]],
          ["ðŸ«¤", "face with diagonal mouth", ["diagonal mouth", "uncertain"]],
          ["ðŸ˜¬", "grimacing face", ["grimace", "awkward"]],
          ["ðŸ˜", "neutral face", ["neutral", "meh"]],
          ["ðŸ˜‘", "expressionless face", ["expressionless", "blank"]],
          ["ðŸ˜’", "unamused face", ["unamused", "annoyed"]],
        ];
        const faceMonkeys = [
          ["ðŸ™ˆ", "see-no-evil monkey", ["monkey", "see-no-evil"]],
          ["ðŸ™‰", "hear-no-evil monkey", ["monkey", "hear-no-evil"]],
          ["ðŸ™Š", "speak-no-evil monkey", ["monkey", "speak-no-evil"]],
          ["ðŸµ", "monkey face", ["monkey", "face"]],
        ];
        const faceCats = [
          ["ðŸ±", "cat face", ["cat", "face"]],
          ["ðŸ˜º", "grinning cat", ["cat", "grin"]],
          ["ðŸ˜¸", "grinning cat with smiling eyes", ["cat", "smiling eyes"]],
          ["ðŸ˜¹", "cat with tears of joy", ["cat", "joy"]],
          ["ðŸ˜»", "smiling cat with heart-eyes", ["cat", "love"]],
          ["ðŸ˜¼", "cat with wry smile", ["cat", "wry"]],
          ["ðŸ˜½", "kissing cat", ["cat", "kiss"]],
          ["ðŸ™€", "weary cat", ["cat", "weary"]],
          ["ðŸ˜¿", "crying cat", ["cat", "crying"]],
          ["ðŸ˜¾", "pouting cat", ["cat", "pout"]],
        ];
        const faceBabies = [["ðŸ‘¶", "baby", ["baby", "child"]]];
        function toObjs(arr) {
          return arr.map(([e, name, k]) => ({
            emoji: e,
            name,
            keywords: [e, name, ...(k || [])],
          }));
        }
        const curated = [
          ...toObjs(faceBabies),
          ...toObjs(faceMonkeys),
          ...toObjs(faceCats),
          ...toObjs(faceUnhappy),
          ...toObjs(faceCore),
        ];
        // Ensure ALL face emojis are at the top (curated â†’ explicit faces â†’ generated faces),
        // followed by common extras, then the rest.
        const FACE_EXTRA_CP = new Set([0x2639, 0x263a]); // â˜¹ï¸, â˜ºï¸
        function isGeneratedFace(item) {
          const cpVal = item.cp;
          if (typeof cpVal === "number") {
            if (cpVal >= 0x1f600 && cpVal <= 0x1f64f) return true; // Emoticons block
            if (FACE_EXTRA_CP.has(cpVal)) return true;
          }
          return false;
        }

        const seen = new Set();
        const result = [];
        const pushUnique = (it) => {
          if (!seen.has(it.emoji)) {
            seen.add(it.emoji);
            result.push(it);
          }
        };

        for (const it of curated) pushUnique(withTitle(it));
        for (const it of extraFaceObjs) pushUnique(withTitle(it));
        for (const it of list) {
          if (isGeneratedFace(it)) pushUnique(withTitle(it));
        }
        for (const it of extraCommonObjs) pushUnique(withTitle(it));
        for (const it of list) {
          if (!seen.has(it.emoji)) pushUnique(withTitle(it));
        }

        return result;

        function withTitle(obj) {
          if (obj.name) return obj;
          // Derive a readable fallback name from keywords or codepoints
          const fromKw = (obj.keywords || []).find(
            (k) => typeof k === "string" && /[a-z]/i.test(k) && !/^U\+/.test(k)
          );
          const name = fromKw || codepointLabel(obj.emoji);
          return Object.assign({}, obj, { name });
        }
      }

      const ALL_EMOJIS = (function () {
        try {
          return generateEmojiSet();
        } catch {
          return [];
        }
      })();
      const searchInput = document.getElementById("search");
      const grid = document.getElementById("grid");
      const scrollArea = document.getElementById("scrollArea");

      // Incremental rendering for performance
      let currentResults = ALL_EMOJIS;
      let renderedCount = 0;
      const CHUNK = 300;

      function clearGrid() {
        grid.innerHTML = "";
        renderedCount = 0;
      }

      const emojiImageCache = new Map(); // emoji -> objectURL
      const requestedEmojis = new Set();
      const btnObserver = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (!entry.isIntersecting) continue;
            const el = entry.target;
            const emoji = el.dataset.emoji;
            if (!emoji) continue;
            if (emojiImageCache.has(emoji)) {
              applyEmojiImage(el, emojiImageCache.get(emoji));
              btnObserver.unobserve(el);
              continue;
            }
            if (isWindows && !requestedEmojis.has(emoji)) {
              requestedEmojis.add(emoji);
              parent.postMessage(
                {
                  pluginMessage: {
                    type: "request-emoji-image",
                    payload: { emoji },
                  },
                },
                "*"
              );
            }
          }
        },
        { root: scrollArea, threshold: 0.3 }
      );

      window.addEventListener("message", (ev) => {
        const msg = ev.data && ev.data.pluginMessage;
        if (!msg || msg.type !== "emoji-image") return;
        const { emoji, bytes } = msg.payload || {};
        if (!emoji || !bytes) return;
        if (!emojiImageCache.has(emoji)) {
          const blob = new Blob([new Uint8Array(bytes)], { type: "image/png" });
          const url = URL.createObjectURL(blob);
          emojiImageCache.set(emoji, url);
        }
        // Apply to any visible buttons with this emoji
        const nodes = document.querySelectorAll(
          `button.emoji-btn[data-emoji="${cssEscape(emoji)}"]`
        );
        nodes.forEach((n) => applyEmojiImage(n, emojiImageCache.get(emoji)));
      });

      function applyEmojiImage(buttonEl, url) {
        if (!buttonEl || !url) return;
        buttonEl.style.backgroundImage = `url(${url})`;
        buttonEl.style.backgroundSize = "70% 70%";
        buttonEl.style.backgroundRepeat = "no-repeat";
        buttonEl.style.backgroundPosition = "center";
        const span = buttonEl.querySelector("span");
        if (span) span.textContent = "";
      }

      function cssEscape(str) {
        // Minimal escape for attribute selectors
        return String(str).replace(/"/g, '\\"');
      }

      function renderNextChunk() {
        if (renderedCount >= currentResults.length) return;
        const frag = document.createDocumentFragment();
        const end = Math.min(renderedCount + CHUNK, currentResults.length);
        for (let i = renderedCount; i < end; i++) {
          const { emoji, name } = currentResults[i];
          const btn = document.createElement("button");
          btn.className = "emoji-btn";
          btn.type = "button";
          // Render emoji using a dedicated span to avoid layout reflows clearing text
          const span = document.createElement("span");
          span.textContent = emoji;
          btn.appendChild(span);
          btn.dataset.emoji = emoji;
          btn.title = getTitle({ emoji, name });
          btn.addEventListener("click", () => insertEmoji(emoji));
          // Observe for viewport entry to apply PNG fallback on any OS if needed
          btnObserver.observe(btn);
          frag.appendChild(btn);
        }
        grid.appendChild(frag);
        renderedCount = end;
        updateScrollButtons();
      }

      function refreshGrid() {
        clearGrid();
        // Use rAF to keep UI responsive
        requestAnimationFrame(renderNextChunk);
      }

      scrollArea.addEventListener("scroll", () => {
        if (
          scrollArea.scrollTop + scrollArea.clientHeight >=
          scrollArea.scrollHeight - 40
        ) {
          renderNextChunk();
        }
        updateScrollButtons();
      });

      function filterEmojis(query) {
        const q = query.trim().toLowerCase();
        if (!q) return ALL_EMOJIS;
        // Match against CLDR name, keywords, emoji itself, and codepoint label
        return ALL_EMOJIS.filter((item) => {
          if (item.name && item.name.toLowerCase().includes(q)) return true;
          for (const kw of item.keywords) {
            if ((kw + "").toLowerCase().includes(q)) return true;
          }
          return false;
        });
      }

      const onInput = debounce(() => {
        currentResults = filterEmojis(searchInput.value);
        refreshGrid();
      }, 120);

      searchInput.addEventListener("input", onInput);
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const first = currentResults[0];
          if (first) insertEmoji(first.emoji);
        }
      });

      function insertEmoji(emoji) {
        parent.postMessage(
          { pluginMessage: { type: "insert-emoji", payload: { emoji } } },
          "*"
        );
        addRecent(emoji);
      }

      function getTitle(item) {
        const label = item.name || codepointLabel(item.emoji);
        return `${label} ${item.emoji}`;
      }

      function codepointLabel(str) {
        const cps = [];
        for (const ch of Array.from(str)) {
          const cp = ch.codePointAt(0);
          if (cp != null) cps.push("U+" + cp.toString(16).toUpperCase());
        }
        return cps.join(" ");
      }

      // Recents section
      const recentsEl = document.getElementById("recents");
      const recentTitleEl = document.getElementById("recentTitle");
      function addRecent(emoji) {
        parent.postMessage(
          { pluginMessage: { type: "add-recent", payload: { emoji } } },
          "*"
        );
      }
      function renderRecents(list = []) {
        recentsEl.innerHTML = "";
        recentTitleEl.style.display = list.length ? "" : "none";
        for (const emoji of list.slice(0, 10)) {
          const btn = document.createElement("button");
          btn.className = "emoji-recent";
          btn.dataset.emoji = emoji;
          const span = document.createElement("span");
          span.textContent = emoji;
          btn.appendChild(span);
          btn.title = getTitle({ emoji, name: undefined });
          btn.addEventListener("click", () => insertEmoji(emoji));
          btnObserver.observe(btn);
          recentsEl.appendChild(btn);
        }
      }
      // Request recents from main on load
      parent.postMessage({ pluginMessage: { type: "get-recents" } }, "*");
      window.addEventListener("message", (ev) => {
        const msg = ev.data && ev.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "recents") {
          renderRecents(Array.isArray(msg.payload) ? msg.payload : []);
        }
      });

      // Scroll arrow buttons
      const btnDown = document.getElementById("btnDown");
      const btnUp = document.getElementById("btnUp");
      btnDown.addEventListener("click", () => {
        scrollArea.scrollTo({
          top: scrollArea.scrollHeight,
          behavior: "smooth",
        });
      });
      btnUp.addEventListener("click", () => {
        scrollArea.scrollTo({ top: 0, behavior: "smooth" });
      });
      function updateScrollButtons() {
        const canScroll =
          scrollArea.scrollHeight > scrollArea.clientHeight + 20;
        const atTop = scrollArea.scrollTop <= 10;
        const atBottom =
          scrollArea.scrollTop + scrollArea.clientHeight >=
          scrollArea.scrollHeight - 10;
        document.getElementById("btnDown").style.display =
          canScroll && !atBottom ? "flex" : "none";
        document.getElementById("btnUp").style.display =
          canScroll && !atTop ? "flex" : "none";
      }
      updateScrollButtons();

      // Initial render
      refreshGrid();
      searchInput.focus();
    </script>
  </body>
</html>
